% -*- mode: latex; TeX-engine: xetex; LaTeX-command-style: (("" "SOURCE_DATE_EPOCH=0 %(PDF)%(latex) --shell-escape %S%(PDFout)")); TeX-master: "../dissertation.tex"; -*-

\chapter{Computer Control of the Experiment}
\label{ch:computer-control}

\section{Introduction}
\label{ch:computer-control:introduction}

The experiment sequence and data taking is managed by computers.
In addition to controlling the timing and the actions during a sequence,
the computer control system is also the main interface
between the people running the experiment~(the user),
the data and the hardware performing the manipulation and measurements.
Because of its central role in the experiment,
it has to satisfy many requirements so that
the daily operation of the lab can be performed smoothly and reliably.
\begin{enumerate}
\item Full control and utilization of hardware.\\
  The control system is a layer in between the user and the hardware
  and will abstract and manage the hardware on behalf of the user.
  However, the abstraction must still allow the user to take advantage of
  the full capability of the hardware, e.g. output resolution, timing accuracy etc.
  This is because there is usually little margin between the capability of the hardware
  and the requirement in the experiment as the specification of the hardware
  is often selected based on the requirement to begin with.
\item Usability for all lab members.\\
  The lab is operated by users with specialty in physics rather than computer science.
  Although some basic knowledge of computer programming is required for operating
  the experiment as well as analysing data,
  the computer control system must be fully usable by people without any experience
  in building complex software systems.\\
  The inevitable complexity of the system must be fully hidden from the user
  for normal operations although more direct control may still be allowed in certain cases.
\item Modeling of the sequence and scan.\\
  As an important special case of usability,
  the computer control system must provide an description for each task close to
  the users' mental model.
  More concretely, this means creating abstraction for concepts
  typically used to describe the task and allow operation on these abstractions
  matching the users' expectation.
  We will talk about concrete examples of this requirement
  in section~\ref{ch:computer-control:frontend} regarding the sequence frontend
  and section~\ref{ch:computer-control:scan} regarding scan automation.
\item Reproducibility.\\
  When exploring something new in the experiment,
  trial and error is the standard method and troubleshooting is a major part of the process.
  The ability to do this effectively requires a high degree of reproducibility of all the results.
  While it is impossible and also not the job of the computer control system to
  eliminate all the fluctuations and noise in the experiment,
  it should not add to the randomness of the system.
  With few exceptions, identical user input should produce identical output from
  the control system.
\item Version control.\\
  Related to and complementing the reproducibility requirement,
  we must be able to revert to a previous software configuration at a later time
  in order to reproduce and double-check an earlier result.
  The use of a proper version control system on the settings and code for
  the computer control system can allow this with additional features
  including easy visualization of setting change and parallel development of code
  by multiple users.
\end{enumerate}

The design of the computer control system is mainly guided by these requirements.
In the next sections, we will go into more detail as we describe each part of the system.
The application programming interface~(API) provided for sequence and scan programming
are mostly text based due to the flexibility and version control requirement.
Some graphic user interfaces~(GUI) are also included for specific tasks
built on top of the text interface but will not be covered in this chapter.
Section~\ref{ch:computer-control:frontend} will cover the frontend of the system
which is used by the user directly to specify an experimental sequence.
Section~\ref{ch:computer-control:backend} will discuss the support for various
hardware backends used to run a sequence.
After that, section~\ref{ch:computer-control:scan} describes how multiple sequences
can be put together to form a scan and section~\ref{ch:computer-control:summary}
discusses some planned updates to the system.

\section{Frontend}
\label{ch:computer-control:frontend}

\todo{Concrete example with a simple ramp}

The frontend is the main user interface of the system to specify a sequence.
Its API is designed around a few concepts that can be divided into two categories,
\begin{enumerate}
\item Timing
  \begin{enumerate}
  \item (Sub-)sequence\\
    This represents a series of events that has fixed relative timing.
    Sequences can be nested in other sequences with specific time offsets,
    in which case they are called subsequences.
    Each sequence can only have at most one parent sequence (the top level one has none)
    and zero or more subsequences
    so that all the subsequences in a top level sequence form a tree.
  \item Time step\\
    The time or time period in the sequence when one or more events may happen
    is called a time step.
    Each time step has a length and a position within a unique parent sequence
    and are always the leaves on the sequence tree.
  \end{enumerate}
\item Output
  \begin{enumerate}
  \item Channel\\
    Each device that can generate an output is abstracted into
    one or multiple channels that each output a single number.
    The abstraction depends on the type of the device,
    e.g. voltage value for a digital to analog converter,
    or frequency and amplitude for a computer-controlled sine-wave generator.
  \item Pulse\\
    This represents the actual output for a particular channel.
    The pulse itself does not contain the timing information within the sequence,
    i.e. start and end time.
    Instead, each pulse belongs to a unique time step that specifies the timing.
  \end{enumerate}
\end{enumerate}
Operations on concepts in one category are usually independent of the other
which allows most common modifications to the sequence to be done
with minimum code change, including,
\begin{enumerate}
\item Adding/removing/changing the length of time step or subsequences
  without affecting the relative timing or output in other parts of the sequence.
\item Enabling/disabling output or changing output values
  without changing the time and length of the output.
\end{enumerate}

The sequence programming uses MATLAB as the host language.
Despite not the best choice from the feature or performance aspect,
it offers the following desired properties,
\begin{enumerate}
\item Text based language and therefore easier for version control.
\item Familiarity for physics students.\\
  MATLAB is often used for simulation and data processing.
  It is one of the few languages that most new students will be familiar with.
\item Built-in feature-rich integrated development environment~(IDE).
\item Foreign function interface~(FFI).\\
  Other parts of the system needs to be implemented in other languages
  for various reasons including higher performance.
  It is important that we can call into other languages to allow such a hybrid implementation.
\item Good enough feature set.\\
  MATLAB provides data structures like arrays and hash tables
  as well as handle classes with object identity
  which are important to handle the representation of the sequence.
  It also has a good enough object-oriented programming~(OOP) model
  and operator overload functionality which can simplify the API syntax for the user.
\end{enumerate}

\subsection{Channel Naming}
\label{ch:computer-control:frontend:channel}
Each output channel has a unique name attached for identification.
This name is always a string of the format \verb`<device_id>/<channel>`
where \verb`<device_id>` is a name for the (physical) device
and \verb`<channel>` is an identification of the channel within the device.
The \verb`<device_id>` may not contain ``\verb`/`'' but
neither \verb`<device_id>` nor \verb`<channel>` has globally predefined meaning
and are completely up to the backend to define.
This format allows maximum freedom for the backend to abstract its function
into multiple channels in the most fitting way,
while allowing the generic code to identify the device, and therefore backend,
needed without fully interpreting the channel name.

\subsection{APIs}
\label{ch:computer-control:frontend:api}
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{figures/computer_control_frontend_classes.pdf}
  \caption[Frontend API classes]{
    Frontend class inherit diagram and API lists.
    \label{fig:computer-control:frontend:classes}}
\end{figure}

The system provides the following APIs for sequence creation
that are subject to strict backward compatibility requirements.
The most important APIs are listed in this section.
Fig.~\ref{fig:computer-control:frontend:classes}
provides a short summary of all the classes and methods mentioned in this section.

\subsubsection{Timing}
Subsequences are represented by the \verb`ExpSeqBase` class
and time steps are represented by the \verb`TimeStep` class.
Both \verb`ExpSeqBase` and \verb`TimeStep` are subclasses of \verb`TimeSeq`,
which represent an arbitrary node on the sequence tree.

Most timing related APIs are methods on \verb`ExpSeqBase`.
The most important ones are the ones creating new branches
in the subsequence tree, i.e. \verb`TimeSeq`.
The type of branch created is determined by the parameters passed in~(\verb`<time_params>`),
which can be either
\begin{enumerate}
\item \verb`length, offset=0`\\
  This creates a new \verb`TimeStep` with a numerical \verb`length`
  and an optional time \verb`offset` from an API dependent time reference point
  (see list of APIs below).
\item \verb`offset=0, callback, <callback parameters>`\\
  This creates a new \verb`ExpSeqBase` with an optional time \verb`offset`
  the time reference point.
  The new subsequence will be populated by calling \verb`callback`
  with the new sequence followed by \verb`<callback parameters>`.
\end{enumerate}
Since most sequences are built in series, \verb`ExpSeqBase` maintains
a current time~(\verb`curTime`) of the sequence.
Various methods are provided that each act differently with respect to \verb`curTime`.
\begin{enumerate}
\item \verb`addStep(<time_params>)` method\\
  This is the most used method to construct the sequence in series.
  The time reference point is \verb`curTime` and
  \verb`curTime` will be set to the end of the time step or subsequence created.
  A check is made to ensure the \verb`curTime` only moves forward and
  errors if a too negative \verb`offset` large enough in magnitude is specified.
  This ensures that what is added with \verb`addStep` always appears in the final
  sequence in the same order as the program execution order
  which makes the code easier to reason about.
\item \verb`addBackground(<time_params>)` method\\
  The time reference point is \verb`curTime` and no change to \verb`curTime` is made.
\item \verb`addAt(time_point, <time_params>)` method\\
  The time reference point is specified by \verb`time_point` which is of type \verb`TimePoint`.
  See below about \verb`TimePoint`.
\item \verb`addFloating(<time_params>)` method\\
  The time reference point is unspecified.
  The optional \verb`offset` parameter cannot be specified in \verb`<time_params>`.
  The time reference point, however, must be specified before the sequence can be run.
  This can be done by calling the \verb`setTime(time_point, time_ratio=0, offset=0)` method
  on the \verb`TimeSeq` object returned,
  where \verb`time_point` is also of type \verb`TimePoint` described below.
  The optional \verb`time_ratio` specifies the relative time within the subsequence
  or time step to set the time for where a value of $0$ sets the start time
  and a value of $1$ sets the end time.
\end{enumerate}
All methods return the new \verb`TimeSeq` constructed so that they can be operated on.

The \verb`TimePoint` object used in \verb`addAt` and \verb`setTime`
can be constructed via \verb`TimePoint(seq, time_ratio, offset)`
which represents the time within the sequence or step \verb`seq` with a time \verb`offset`.
\verb`time_ratio` specifies the time within the \verb`seq` where $0$ is the start time
and $1$ is the end time.

Additional convenience methods for \verb`ExpSeqBase` are also provided
to manipulate \verb`curTime`,
\begin{enumerate}
\item \verb`wait(t)` method\\
  Add \verb`t` to \verb`curTime`.
  This is the only method that can change \verb`curTime` backwards.
\item \verb`waitAll()` method\\
  Forward \verb`curTime` to the end of all (nested) subsequences and time steps
  within the current subsequence.
\item \verb`waitBackground()` method\\
  Similar to \verb`waitAll()` but only wait for the subsequences and time steps
  directly added to the current subsequence.
\item \verb`waitFor(seqs, offset=0)` method\\
  Forward \verb`curTime` to the end of subsequences and time steps specified
  within the array \verb`seqs`.
  An optional \verb`offset` may be added to the latest end time.
\end{enumerate}

\subsubsection{Output}

As mentioned before, all the outputs are specified on time steps
which are represented by the class \verb`TimeStep`.
This is done via a single method \verb`add(channel_name, output)` on \verb`TimeStep`.
The \verb`channel_name` is the channel name described above
and \verb`output` specifies the output in one of the following ways,
\begin{enumerate}
\item A number\\
  This represents setting the channel to the specified value at the start time of the pulse.
\item A function or callable object\\
  The function will be used to compute the value to output over the whole duration of the pulse.
  It will be called with arguments \verb`(t, len, old_val)` where
  \verb`t` is the time within the pulse, \verb`len` is the length of the pulse
  and \verb`old_val` is the previous value of the channel before the current pulse.
\end{enumerate}

\section{Backends}
\label{ch:computer-control:backend}
As discussed in section~\ref{ch:computer-control:frontend},
the frontend provides an API to program all the output channels in the same way
no matter the type of the channel or device used.
However, this is not the case for the devices generating the output
which often have an API specifically designed for the device
that may be very different from one another.
Moreover, the frontend represents the sequence as a tree structure
that is convenient for manipulation
whereas the device API typically uses a flat data structure like an array of numbers
or a series of commands.
It is therefore the job of the backend to bridge this gap
and convert between the multiple representations of the sequence.
The conversion is done in a ``generation'' step and
the result is cached for each sequence to allow running the sequence
multiple times with minimum overhead.

The specific requirements and implementations for each backend are very different.
Nevertheless, there are a few important features or components that are shared among
different backends.

\subsection{Network Communication}
\label{ch:computer-control:backend:net}
With one current exception, the output devices are not directly connected to
the computer running the frontend but are only connected to another computer
on the same network.
This requires network communication between the frontend machine and
a service running on the device computer to run the sequence.

We use ZeroMQ Message Transport Protocol~(ZMTP) as the main protocol for network communication
which offers the following advantages,
\begin{enumerate}
\item Binary protocol\\
  The protocol allows us to send and receive arbitrary data without having to encode it
  into text first. This saves encoding and decoding time as well as network bandwidth
  which allows higher performance.
\item Feature rich and flexible\\
  Compared to using sockets for network communication directly,
  the message oriented protocol allows easy implementation of remote procedure call~(RPC).
  The ZeroMQ library also provides a flexible interface to process the messages
  which is useful to implement robust handling of failure
  and parallel processing of requests.
\item Lightweight\\
  Despite the rich feature set, the library is relatively lightweight.
  This is important because part of the computer control system
  needs to be executed in an environment with limited resources.
\item Cross platform\\
  The library is cross platform and provides identical API on different environments.
  Windows support is particularly important since most of the development is done
  on Linux machines.
\item Stable\\
  Both the protocol and the library are stable.
  The library versions available on different machines are not always the same
  and it is important that the same version of code can work on different machines
  and can communicate with each other in all cases.
\end{enumerate}

\subsection{Sorting of Pulses}
\label{ch:computer-control:backend:sort-pulse}
The tree representation of the sequence is useful for construction and manipulation
but contains unnecessary information for generating output,
for which only the pulses and their start and end time
within the top-level sequence is important but not the subsequence structure.
Because of this, all the backends start the generation step by
flattening the tree to obtain a list of all pulses sorted by their start time.
After the sorting of the pulses, the tree structure is discarded by default\footnote{
  This behavior can be disabled for debugging purposes.} to reduce memory usage.

\subsection{Representation of Pulses}
\label{ch:computer-control:backend:pulse-repr}
Several backends require accessing the exact representation of the pulses
outside the MATLAB code and even on different computers.
Since the pulses can be arbitrary functions,
this requires the ability to serialize and deserialize code.

In order to do this, we developed a simple intermediate representation~(IR)
of the code that runs on a register-based virtual machine.
The IR supports three different data types, \verb`Bool`, \verb`Int32` and \verb`Float64`
and basic arithmetic, control flow and math functions
that are sufficient for specifying pulse shapes.
The IR can be interpreted by an interpreter written in C++ or
be compiled and optimized to native code for faster execution using an LLVM based compiler.

In order to convert MATLAB functions specified in the sequence to the IR,
we pass in a special object as the input argument to the MATLAB function.
Supported operations on this object will return a new object
that records the operation as well as input arguments.
The value returned from the function is therefore an object representing
all the operations needed to compute the result as a directed acyclic graph~(DAG).
We then convert each node in the DAG to an IR instruction to finish the conversion.
This process only supports pure functions.
Conditional branching is supported via an \verb`ifelse` function
that returns one of the input arguments based on a condition.
Loops are not currently supported.

\subsection{FPGA Backend}
\label{ch:computer-control:backend:fpga}
\begin{figure}
  \centering
  \includegraphics[width=0.9\textwidth]{figures/computer_control_backend_fpga.pdf}
  \caption[FPGA Block Diagram]{
    FPGA hardware block diagram.
    The sequence data is sent to the server program running on the CPU through the network.
    The program then pushes the commands to the pulse controller implemented
    in the programming logic.
    The pulse controller executes the commands and generates or changes the outputs
    for clock/trigger, DDS or logical outputs.
    \label{fig:computer-control:backend:fpga}}
\end{figure}
The timing of the experiment is controlled by a Xilinx ZC702 FPGA
which contains both a processing system~(PS) part, i.e. CPU,
and a programmable logic~(PL) part, i.e. FPGA~(Fig.~\ref{fig:computer-control:backend:fpga}).
The PL creates digital control signals for various peripheral devices
which generate the outputs for the experiment,
including direct digital synthesizers~(DDS), logical switching signal
and clock or trigger signal for other devices.
The PS consists of a dual core Cortex-A9 CPU
which runs an Arch Linux ARMv7 distribution.
The server software that runs on the PS communicates with the main control computer
via ZeroMQ~(section~\ref{ch:computer-control:backend:net})
and generates a custom command stream to control the PL output.
Each command corresponds to making one change to the final output, e.g.
logical values, DDS output amplitudes or frequencies, etc.
The main job of the FPGA backend is therefore to convert
the sorted pulses to the command stream.
See appendix~\ref{appendex:computer-control:fpga} and \ref{appendex:computer-control:dds}
for more information about the hardware specification.

Due to performance concerns, this conversion is done in C++ code\footnote{\url{https://github.com/nacs-lab/libnacs/blob/0076e347ff3ba674fbf74872883b40feefd82ce0/lib/seq/bytecode.cpp\#L528}}.
The main design considerations and features are,
\begin{enumerate}
\item The sequence supports changing and ramping multiple channels at the same time.
  This is not supported by the hardware due to the limit on the number of I/O ports
  connecting the PL to the output devices requiring multiplexing of the control signal.
  The backend manages this by interleaving the commands for different channels
  when more than one channel is changed at the same time.
  A set of active pulses is maintained as the conversion proceeds through the sequence time.
  Pulses are added to the active set when the start time is reached
  and retired from the set when the end time is reached.
\item For a continuous ramp of a channel, since the output changes are discrete,
  it may not happen at exactly the end time of the pulse
  which requires special care to ensure the correctness of the channel value after a pulse.
  For example, a linear ramp from $0$ to $0.5$ on a channel from time $0~\mathrm{\mu s}$
  to $5~\mathrm{\mu s}$ may only receive updates at times $0, 2, 4~\mathrm{\mu s}$
  with values $0.0, 0.2, 0.4$ respectively due to discretization.
  However, the user should expect the value of the channel (in the absence of other pulses)
  long after the pulse to be $0.5$.
  This is handled in the backend by checking the last update from the pulse
  against its expected ending value before retiring it.
  A final update to the ending value is generated if the two values are different.
\item The output has finite resolution.
  If an update changes the value that is unresolved by the hardware
  (typically during a slow ramp), the update will be omitted.
\item Some commands correspond to more than one action/pulse in the sequence.
  For example, more than one logical output can be updated at the same time
  and some commands also accept a variable wait time afterwards
  (in addition to a special purpose wait command).
  The backend examines neighboring operations and may merge multiple commands into one.
  This is especially useful for logical outputs.
  In fact, logical output changes that are specified to happen at the same time in the sequence
  are guaranteed to happen at the same time in the experiment as well.
\item The PL commands are fixed length to allow a simpler implementation
  of command parsing in the PL.
  However, since not all commands contain the same amount of information,
  some include padding for alignment.
  In order to save network bandwidth, a compressed format with variable command length
  and no padding is used to transfer the commands through the network.
  The decompression is done when running the sequence on the CPU right before
  sending to the PL for execution.
\end{enumerate}

\subsection{NiDAQ Backend}
\label{ch:computer-control:backend:nidaq}
For outputting slowly varying voltage signals, we use a DAQ PCI card
(more detail in appendix~\ref{appendex:computer-control:nidaq}).
The software driver for the card accepts an array of numbers as the voltages
to output at each clock cycle for each of the channels.
Since the values in these arrays can be computed for each channel independently,
the logic for generating them is relatively straightforward.

The API for the card is designed for updating the outputs at regular intervals.
However, there are a few issues when it is used this way,
\begin{enumerate}
\item The same sampling rate is used when frequent updates to the output are needed
  and when the outputs are held at a constant value.\\
  Since output voltages are usually only being varied for a short time compared
  to the length of the sequence,
  this causes significant duplication in the data causing a waste of memory.
\item We measured voltage noise at the refresh rate when the output is held constant
  by outputting samples at the same value.\\
  While this is a hardware limit that cannot easily be fixed when the values are changing,
  being able to turn off the refreshing gives us control to minimize its effect
  on the experiment.
\end{enumerate}
Because of these issues, we control the refresh by gating the clock input to the output card.
When there are channels to be updated, the clock is turned to the maximum speed.
Otherwise, the clock is kept off so no refreshing is happening.
Since the clock signal is generated by the FPGA, the gating is done
by passing the clock on/off intervals computed by the NiDAQ backend to the FPGA backend.
Since an extra or missing clock cycle may cause the output value during hold time
to be significantly different from the desired value,
the FPGA backend guarantees that the clock control commands are always scheduled
at the exact time so that the exact number of clock cycles can be sent to the output card.

We also observed that the driver of the card may timeout if not enough clock signals are received
at the beginning of the sequence. We therefore always send $1~\mathrm{ms}$
of clock signals to the card at the beginning of the sequence to work around this issue.

\subsection{USRP Backend}
\label{ch:computer-control:backend:usrp}

In addition to the DDSs attached to the FPGA, we also support generation of
radio frequency~(RF) signals using universal software radio peripheral~(USRP)
(more detail in appendix~\ref{appendex:computer-control:nidaq}).
Compared to the DDS, which can only output a single frequency at a time,
USRP supports the output of arbitrary spectra within a certain range.
This can be useful when more than one frequency is needed on a single channel,
e.g. for fast modulation of the amplitude using beating,
or to generate multiple diffraction orders on an acousto optical beam deflector~(AOBD).

Since most usage of the USRP output involves creating multiple discrete frequencies,
the hardware is modelled in our system accordingly.
Instead of mapping the physical output channel to a fixed number of parameters
similar to all the previously mentioned backends,
a ``virtual'' output channel is created for each tone in the output,
and can be controlled independently similar to all other channels.
The \verb`<device_id>` component of the channel name has format \verb`CH<n>/<param>`
where \verb`<n>` is a number identifying the virtual channel
and \verb`<param>` is the parameter controlling the virtual channel,
e.g. \verb`FREQ` for frequency or \verb`AMP` for amplitude.

The driver API for USRP is very similar to that of the NI output card
and requires the output value to be provided at a regular time interval.
However, due to the constant changing nature of the RF output and the higher sampling rate,
the memory requirement would be too high if we take the same approach as the NiDAQ backend
and compute all the output values before the sequences start.
Instead, the backend uses a command stream similar to the one used by the FPGA backend
to encode the change to the output spectra.
Unlike the FPGA backend, however, commands can be issued
for all the virtual channels simultaneously,
removing the need to interleave updates for different channels.

From the command stream, we generate the output at a sampling rate of $50~\mathrm{MS/s}$.
The samples are computed on the fly which allows maximum flexibility
and minimizes the time needed to generate the data before each sequence.
The data throughput necessary to generate samples at the high rate is achieved
thanks to the AVX2 instructions,
which allows computation of multiple sine and cosine functions simultaneously\footnote{
  The AVX2 implementation of the math functions used is based on work by
  \href{https://github.com/reyoung}{Yu Yang} at \url{https://github.com/reyoung/avx_mathfun}
  which is based on work at \url{http://software-lisc.fbk.eu/avx_mathfun/}
  by \href{mailto:garberoglio@fbk.eu}{garberoglio@fbk.eu}.
}. In order not to interfere with the user interface tasks
and to achieve more reliable performance for the sample generation,
the program directly managing the USRP device runs on a separate computer running Linux.
The communication with the main computer is done via ZMTP.

The USRP device does not have built-in support for triggering,
which is necessary to synchronize its output with other devices.
We implement this in software by converting the trigger signal to a COM port signal
using an Arduino board and monitoring the COM port in the USRP server program.
The trigger has a timing accuracy of $1~\mathrm{ms}$
which is limited either by the timing of the Arduino or
the reading of the COM port on the server computer.

\section{Automation of Scans}
\label{ch:computer-control:scan}

The core of the control system, as described in the previous sections,
deals with the specification and realization of experimental sequences,
which are the building blocks for all measurements we do.
However, most experiments require running multiple sequences
to reduce statistical uncertainty and measure the effect of varying certain parameters.
We add the concept of scans to the system in order to satisfy this requirement.
A scan is a set of sequences where one or more experimental parameters are varied
across the sequences.
When running the scan, the system automatically selects sequences
from the scan to run in random order in order to reduce potential systematic effects
due to interference between sequences.
The scan can be configured to run for a set number of times
or until some predetermined conditions are satisfied,
which in our experiment typically happens
when a certain number of single atom loading events happens.

The scan interacts with the sequence constructing code
by storing the parameters for the scan in the sequence object \verb`s` as a nested structure,
which is accessed as \verb`s.C`.
Each substructure within the parameters can be accessed and passed independently
which allows multiple instances of a common subsequence
to store their parameters in the same way within the parent structure.
As an example, a subsequence construction function may be implemented as
\begin{lstlisting}[language=Matlab]
  function subseq(s, p)
    % Access parameter1, with default value 0
    parameter1 = p.parameter1(0);
    % Access parameter2, which must be predefined
    parameter2 = p.parameter2();
    % ... Use parameter1 and parameter2 to construct s.
  end
\end{lstlisting}
which may be used in the parent sequence as
\begin{lstlisting}[language=Matlab]
  % Construct one instance of the subsequence
  % using substructure under Instance1
  s.addStep(@subseq, s.C.Instance1);
  % ...
  % Construct another instance of the subsequence
  % using substructure under Instance2
  s.addStep(@subseq, s.C.Instance2);
\end{lstlisting}

The scan is represented by a \verb`ScanGroup` object,
which provides the following functions to construct a scan.
\begin{itemize}
\item A \verb`ScanGroup` can store multiple basic scans each containing
  a multiple dimensional scan (see below) of parameters.
  The basic scans within a \verb`ScanGroup` \verb`sg` can be accessed through
  indexing, e.g. \verb`sg(1)`.
\item Multiple \verb`ScanGroup` \verb`sg1`, \verb`sg2`, \verb`sg3`, or the basic scans included
  can be concatenated into a single \verb`ScanGroup` via the concatenation syntax, e.g.
  \begin{lstlisting}[language=Matlab]
  [sg1, sg2, sg3(1), sg3(4)]
\end{lstlisting}
  This allows multiple different scans to run simultaneously,
  which is useful when running the experiment unattended for a long time, e.g. overnight.
\item Within a basic scan,
  the parameter can be set to a fixed value via assignment, e.g.
  \begin{lstlisting}[language=Matlab]
  sg(2).Instance1.parameter1 = 2;
\end{lstlisting}
\item Each basic scan allows multiple parameters to be scanned simultaneously
  forming a multidimensional array of parameters.
  A scan of the parameter along dimension \verb`i` can be configured
  by assigning values to \verb`.scan(i)` of the parameter, e.g.
  \begin{lstlisting}[language=Matlab]
  sg(1).Instance1.parameter2.scan(2) = [1, 2, 3, 4];
\end{lstlisting}
\item Multiple parameters can also be scanned along the same dimension
  in which case the length of the parameter values must be the same. E.g.
  \begin{lstlisting}[language=Matlab]
  sg(1).Instance1.parameter2.scan(2) = [1, 2, 3, 4];
  sg(1).Instance2.parameter2.scan(2) = [2, 3, 4, 5];
\end{lstlisting}
  is supported whereas
  \begin{lstlisting}[language=Matlab]
  sg(1).Instance1.parameter2.scan(2) = [1, 2, 3, 4];
  sg(1).Instance2.parameter1.scan(2) = [2, 3, 4];
\end{lstlisting}
  will raise an error.
\item Parameters, fixed or scanned, can be set for all the basic scans in the \verb`ScanGroup`
  by assigning to the empty index, e.g.
  \begin{lstlisting}[language=Matlab]
  sg().Instance1.parameter1 = 3;
  sg().Instance1.parameter2.scan(1) = [2, 3, 4];
\end{lstlisting}
\end{itemize}

\section{Summary and Outlook}
\label{ch:computer-control:summary}

We have designed a computer control system for the experiment
that is power and flexible yet requires minimum low level knowledge from the user.
All the measurements done in this thesis are implemented using this system.

The design of the system, especially the user API,
guarantees that continuous improvement can be made
without major changes to existing user code.
Examples of further improvements that could be made to the system include,
\begin{enumerate}
\item Unlike other backends, the FPGA determines the timing of the experiment
  and only one instance of such a device is allowed per experiment.
  This limits the number of output channels we can use that are attached to the FPGA
  (i.e., DDS and logical outputs).
  Allowing the FPGA to use an external clock could make it possible
  to use more than one FPGA in the experiment
  and thus increase the number of channels available.
\item Support for more devices can be added to the system.\\
  One such update in progress uses the arbitrary waveform generator~(AWG) boards
  from Spectrum Instrumentation.
  These are very similar to the USRP devices but the outputs have higher bandwidth
  and significantly lower noise.
\item The IR execution is one of the main factors affecting the performance
  of the sequence compilation.
  In addition to the compilation to native code mentioned previously,
  the function can also be vectorized to take advantage of SIMD instructions
  in order to further improve the performance.
\item The sequence is currently static and cannot depend on measured value
  during the experiment as feedback.
  Dynamic or runtime logic can be added to the sequence
  by recording and encoding the necessary logic that needs to happen at runtime
  in a similar way we convert MATLAB code to the IR.
  Such capability will be important for implementing rearrangement of tweezers
  in order to achieve high filling fractions.
\end{enumerate}
