% -*- mode: latex-mode; TeX-engine: xetex; LaTeX-command-style: (("" "SOURCE_DATE_EPOCH=0 %(PDF)%(latex) --shell-escape %S%(PDFout)")); TeX-master: "../dissertation.tex"; -*-

\chapter{Computer Control of the Experiment}
\label{ch:computer-control}

\section{Introduction}

The experiment sequence and data taking is managed by computers.
In additional to controlling the timing and the actions during a sequence,
the computer control system is also the main interface
between the people running the experiment (the user),
the data and the hardware performing the manipulation and measurements.
Because of its central role in the experiment,
it has to satisfy many requirements so that
the daily operation of the lab can be performed smoothly and reliably.
\begin{enumerate}
\item Full control and utilization of hardware.\\
  The control system is a layer in between the the user and the hardware
  and will abstract and manage the hardware on behave of the user.
  However, the abstraction must still allow the user to take advantage of
  the full capability of the hardware, e.g. output resolution, timing accuracy etc..
  This is because there is usually little margin between the capability of the hardware
  and the requirement in the experiment as the specification of the hardware
  is often selected based on the requirement to begin with.
\item Usability for all lab members.\\
  The lab is operated by users with specialty in physics rather than computer science.
  Although some basic knowledge of computer programming is required for operating
  the experiment as well as analysing data,
  the computer control system must be fully usable for people without any experience
  in building complex software systems.\\
  The inevitable complexity of the system must be fully hidden from the user
  for normal operations although more direct control may still be allowed in certain cases.
\item Modeling of the sequence and scan.\\
  As an important special case of usability,
  the computer control system must provide a model for each tasks closed to
  the users' mental model.
  More concretely, this means creating abstraction for concepts
  typically used to describe the task and allow operation on these abstractions
  matching the users' expectation.
  We will talk about concrete examples of this requirements
  in section \ref{ch:computer-control:frontend} regarding the sequence frontend
  and section \ref{ch:computer-control:scan} regarding scan automation.
\item Reproducibility.\\
  When exploring something new in the experiment,
  trial and error is the standard method and troubleshooting is a major part of the process.
  The ability to do this effectively requires a high degree of reproducibility of all the result.
  While it is impossible and also not the job of the computer control system to
  eliminate all the fluctuation and noise in the experiment,
  it should not add to the randomness of the system.
  With few exceptions, identical user input should produce identical output from
  the control system.
\item Version control.\\
  As a variation of the reproducibility requirement and also built on top of it,
  we must be able to revert to a previous software configuration at a later time
  in order to reproduce and double-check an earlier result.
  The use of a proper version control system on the settings and code for
  the computer control system can allow this with additional features
  including easy visualization of setting change and parallel development of code
  by multiple users.
\end{enumerate}

The design of the computer control system is mainly guided by these requirements
and we will go into more detail as we describe each part of the system.
The application programming interface (API) provided for sequence and scan programming
are mostly text based due to the flexibility and version control requirement.
Some graphic user interface (GUI) are also included for specific tasks
built on top of the text interface but will not be covered in this chapter.
Section \ref{ch:computer-control:frontend} will cover the frontend of the system
which is used by the user directly to specify an experimental sequence.
Section \ref{ch:computer-control:backend} will discuss the support for various
hardware backends used to run a sequence.
After that, section \ref{ch:computer-control:scan} describes how multiple sequences
can be put together to form a scan and
we will talk about some planned update to the system in section
\ref{ch:computer-control:summary}.

\section{Frontend}
\label{ch:computer-control:frontend}

The frontend is the main user interface of the system to specify a sequence.
Its API is designed around the a few concepts that can be divided into two categories,
\begin{enumerate}
\item Timing
  \begin{enumerate}
  \item (Sub-)sequence\\
    This represent a series of events that has fixed relative timing.
    Sequences can be nested in other sequences at a specific time offset
    and are called subsequences.
    Each sequence can only have at most one parent sequence (the top level one has none)
    and zero or more subsequences so all the subsequences in a top level sequence forms a tree.
  \item Time step\\
    The time or time period in the sequence when one or more event may happen
    is called a time step.
    Each time step has a length and a position within a unique parent sequence.
  \end{enumerate}
\item Output
  \begin{enumerate}
  \item Channel\\
    Each device that can generate an output are abstracted into
    one or multiple channels that each output a single number.
    The abstraction depends on the type of the device,
    e.g. voltage value for a digital to analog converter,
    or frequency and amplitude for an computer-controlled sine-wave generator.
  \item Pulse\\
    This represents the actual output for a particular channel.
    The pulse itself does not contain the timing information within the sequence,
    i.e. start and end time.
    Instead, each pulse belongs to a unique time step that specifies the timing.
  \end{enumerate}
\end{enumerate}
Operations on concepts in one category are usually independent of the other
which allows most common modifications to the sequence to be done
with minimum code change, including,
\begin{enumerate}
\item Adding/removing/changing the length of time step or subsequences
  without affecting the relative timing or output in other part of the sequence.
\item Enabling/disabling output or changing output values
  without changing the time and length of the output.
\end{enumerate}

The sequence programming uses MATLAB as the host language.
Despite not the best choice from the feature or performance aspect,
it offers the following desired properties,
\begin{enumerate}
\item Text based language and therefore easier for version control.
\item Familiarity for physics student.\\
  MATLAB is often used for simulation and data processing.
  It is one of the few languages that most new students will be familiar with.
\item Builtin feature-rich integrated development environment (IDE).
\item Foreign function interface (FFI).\\
  Other parts of the system needs to be implemented in other languages
  for various reasons including higher performance.
  It is important that we can call into other languages to allow such a hybrid implementation.
\item Good enough feature set.\\
  MATLAB provides data structures like arrays and hash table
  as well as handle classes with object identity
  which are important to handle the representation of the sequence.
  It also has an good enough object-oriented programming (OOP) model
  and operator overloads which can simplify the API syntax for the user.
\end{enumerate}

\subsection{APIs}
The system provides the following APIs for sequence creation
that are subject to strict backward compatibility requirements.

\subsubsection{Timing}

        % These functions creates sub node in the sequence DAG
        % which can be either a step (`TimeStep`) or a subsequence (`ExpSeqBase`).
        % (For simplicity, we may call both of these steps below.)
        %
        % The steps are created relative to a certain reference point,
        % which can be,
        % 1. Unknown (to be fixed later): `addFloating`.
        % 2. Known now. The known time could be,
        %     A. Current time of this (sub)sequence,
        %        in which case one decide whether the current time should be updated.
        %         a. Yes: `addStep`
        %
        %             Note that the restriction that `curTime` cannot be decreased applies
        %             so the end of the step added this way must not be before the
        %             previous `curTime`. An error will be thrown if the time offset
        %             specified is too negative and cause this to happen.
        %             (The state of the sequence is unspecified after the error is thrown.)
        %
        %         b. No: `addBackground`
        %     B. A specific `TimePoint`: `addAt`.
        %
        % All the functions use the same syntax to specify the type of
        % the step to be added (`TimeStep` or `ExpSeqBase`),
        % the parameter to construct the step (length for `TimeStep` or
        % callback with arbitrary arguments for `ExpSeqBase`),
        % and the offset relative to the reference point for each function.
        % (The offset cannot be specified for `addFloating`).
        % This is handled by `addStepReal` and the allowed arguments conbinations are,
        %
        % 1. To construct a subsequence (`ExpSeqBase`), a callback is always required.
        %    (The callback can be a function handle, a class, or any callable,
        %    i.e. indexable non-numerical and non-logical object).
        %    Therefore, to construct a subsequence the arguments are,
        %    `([offset=0, ]callback, extra_arguments_for_callback...)`.
        %    The sub sequence will be constructed at the specified time point
        %    and passed to the `callback` (as first argument) followed by the extra
        %    arguments to populate the subsequence.
        % 2. To construct a `TimeStep`, one need to specify only the length.
        %    Since the offset is rarely used, the arguments to construct a `TimeStep` is,
        %    `(len[, offset=0])`. Since `len` in general must be positive, a special case
        %    is when a single negative number is given. The `len` will then be interpreted
        %    as the offset as well as the negative of the length
        %    (e.g. `(-5)` represent a step of length `5` and offset `-5`).
        %
        % In both cases, the step constructed will be returned.
        %% Wait API's
        % Allow waiting for time, background sequences, everything,
        % or specific subsequences or steps.

        % function self = wait(self, t)
        %     %% Forward current time.
        %     self.curTime = self.curTime + t;
        % end

        % function self = waitAll(self)
        %     %% Wait for everything that have been currently added to finish.
        %     % This is the recursive version of `waitBackground`.
        %     self.curTime = totalTime(self);
        % end

        % function self = waitFor(self, steps, offset)
        %     %% Wait for all the steps or subsequences within `steps` with an offset.
        %     % It is allowed to wait for steps or subsequences that are not a child
        %     % of `self`. It is also allowed to wait for floating sequence provided
        %     % that all the floating part is shared (i.e. only the common parents are floating
        %     % and the offset between `self` and the step to be waited for is well defined).
        %     if ~exist('offset', 'var')
        %         offset = 0;
        %     end
        %     t = self.curTime;
        %     for step = steps
        %         if iscell(step)
        %             % Deal with MATLAB cell array indexing weirdness....
        %             real_step = step{:};
        %         else
        %             real_step = step;
        %         end
        %         step_toffset = real_step.tOffset;
        %         if isnan(step_toffset)
        %             error('Cannot get offset of floating sequence.');
        %         elseif isa(real_step, 'TimeStep')
        %             tstep = step_toffset + real_step.len + offset;
        %         else
        %             tstep = step_toffset + real_step.curTime + offset;
        %         end
        %         if real_step.parent ~= self
        %             tstep = tstep + offsetDiff(self, real_step.parent);
        %         end
        %         if tstep > t
        %             t = tstep;
        %         end
        %     end
        %     self.curTime = t;
        % end

        % function self = waitBackground(self)
        %     %% Wait for background steps that are added directly to this sequence
        %     % to finish. See also `waitAll`.
        %     function checkBackgroundTime(sub_seq)
        %         if ~isa(sub_seq, 'ExpSeqBase')
        %             len = sub_seq.len;
        %         else
        %             len = sub_seq.curTime;
        %         end
        %         sub_cur = sub_seq.tOffset + len;
        %         if isnan(sub_cur)
        %             error('Cannot wait for background with floating sub sequences.');
        %         end
        %         if sub_cur > self.curTime
        %             self.curTime = sub_cur;
        %         end
        %     end
        %     subSeqForeach(self, @checkBackgroundTime);
        % end

        % %% Other helper functions.

        % function step = add(self, name, pulse)
        %     %% Convenient shortcut for adding a single pulse in a step.
        %     if ~isnumeric(pulse) && ~islogical(pulse)
        %         error('Use addStep to add a ramp pulse.');
        %     end
        %     % The 10us here is just a placeholder.
        %     % The exact length doesn't really matter except for total sequence length
        %     step = addBackground(self, 1e-6);
        %     add(step, name, pulse);
        % end

        % function res = alignEnd(self, seq1, seq2, offset)
        %     %% Make sure that `seq1` and `seq2` ends at the same time and the longer
        %     % one of which started `offset` after the current time of this sequence.
        %     % Return the input steps as a cell array.
        %     if ~exist('offset', 'var')
        %         offset = 0;
        %     end
        %     if ~isnan(seq1.tOffset) || ~isnan(seq2.tOffset)
        %         error('alignEnd requires two floating sequences as inputs.');
        %     end
        %     if ~isa(seq1, 'ExpSeqBase')
        %         len1 = seq1.len;
        %     else
        %         len1 = seq1.curTime;
        %     end
        %     if ~isa(seq2, 'ExpSeqBase')
        %         len2 = seq2.len;
        %     else
        %         len2 = seq2.curTime;
        %     end
        %     if len1 > len2
        %         seq1.setTime(endTime(self), 0, offset);
        %         seq2.setEndTime(endTime(seq1));
        %     else
        %         seq2.setTime(endTime(self), 0, offset);
        %         seq1.setEndTime(endTime(seq2));
        %     end
        %     res = {seq1, seq2};
        % end

        % function res = totalTime(self)
        %     res = 0;
        %     for i = 1:self.nSubSeqs
        %         sub_seq = self.subSeqs{i};
        %         if isa(sub_seq, 'TimeStep')
        %             sub_end = sub_seq.len + sub_seq.tOffset;
        %         else
        %             sub_end = totalTime(sub_seq) + sub_seq.tOffset;
        %         end
        %         if sub_end > res
        %             res = sub_end;
        %         end
        %     end
        %     if isnan(res)
        %         error('Cannot get total time with floating sub sequence.');
        %     end
        %     if res < self.curTime
        %         res = self.curTime;
        %     end
        % end

        % function tdiff = getTimePointOffset(self, time)
        %     % Compute the offset of a `TimePoint` relative to current sequence
        %     if ~isa(time, 'TimePoint')
        %         error('`TimePoint` expected.');
        %     end
        %     other = time.seq;
        %     tdiff = offsetDiff(self, other);
        %     offset = time.offset;
        %     if time.anchor ~= 0
        %         if ~isa(other, 'ExpSeqBase')
        %             len = other.len;
        %         else
        %             len = other.curTime;
        %         end
        %         offset = offset + len * time.anchor;
        %     end
        %     tdiff = tdiff + offset;
        % end

\subsubsection{Output}
            %% Add a pulse on a channel to the step.
            % The channel name can be provided as a string, which will be
            % translated and converted to the channel ID, or it can be
            % given as the channel ID (number) directly. (See `TimeSeq::translateChannel`)
            % The pulse can be
            %
            % * A number
            %
            %     Output the value at the beginning of the step.
            %
            % * A subclass of `PulseBase`
            %
            %     The `calcValue` method will be used to compute the output value.
            %
            % * Or an arbitrary callable object/function handle.
            %
            %     Equivalent as a `FuncPulse`. The object will be called to
            %     compute the output value.

\section{Backends}
\label{ch:computer-control:backend}
(communication protocol)
(IR)

\subsection{FPGA Backend}
(clock generation)
(pulse merging)
(compression)

\subsection{NiDAQ Backend}
(Variable clock)

\subsection{USRP Backend}
(SIMD)

\section{Automation of Scan}
\label{ch:computer-control:scan}

(Scan requirement)
(Combination of scans)
(Scope/nested structure)

\section{Summary and Outlook}
\label{ch:computer-control:summary}
(new backend/SPCM)
(native code generation, auto vectorization)
(dynamic logic and dependency tracking/optimization)
