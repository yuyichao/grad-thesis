% -*- mode: latex-mode; TeX-engine: xetex; LaTeX-command-style: (("" "SOURCE_DATE_EPOCH=0 %(PDF)%(latex) --shell-escape %S%(PDFout)")); TeX-master: "../dissertation.tex"; -*-

\chapter{Computer Control of the Experiment}
\label{ch:computer-control}

\section{Introduction}

The experiment sequence and data taking is managed by computers.
In additional to controlling the timing and the actions during a sequence,
the computer control system is also the main interface
between the people running the experiment (the user),
the data and the hardware performing the manipulation and measurements.
Because of its central role in the experiment,
it has to satisfy many requirements so that
the daily operation of the lab can be performed smoothly and reliably.
\begin{enumerate}
\item Full control and utilization of hardware.\\
  The control system is a layer in between the the user and the hardware
  and will abstract and manage the hardware on behave of the user.
  However, the abstraction must still allow the user to take advantage of
  the full capability of the hardware, e.g. output resolution, timing accuracy etc..
  This is because there is usually little margin between the capability of the hardware
  and the requirement in the experiment as the specification of the hardware
  is often selected based on the requirement to begin with.
\item Usability for all lab members.\\
  The lab is operated by users with specialty in physics rather than computer science.
  Although some basic knowledge of computer programming is required for operating
  the experiment as well as analysing data,
  the computer control system must be fully usable for people without any experience
  in building complex software systems.\\
  The inevitable complexity of the system must be fully hidden from the user
  for normal operations although more direct control may still be allowed in certain cases.
\item Modeling of the sequence and scan.\\
  As an important special case of usability,
  the computer control system must provide a model for each tasks closed to
  the users' mental model.
  More concretely, this means creating abstraction for concepts
  typically used to describe the task and allow operation on these abstractions
  matching the users' expectation.
  We will talk about concrete examples of this requirements
  in section \ref{ch:computer-control:frontend} regarding the sequence frontend
  and section \ref{ch:computer-control:scan} regarding scan automation.
\item Reproducibility.\\
  When exploring something new in the experiment,
  trial and error is the standard method and troubleshooting is a major part of the process.
  The ability to do this effectively requires a high degree of reproducibility of all the result.
  While it is impossible and also not the job of the computer control system to
  eliminate all the fluctuation and noise in the experiment,
  it should not add to the randomness of the system.
  With few exceptions, identical user input should produce identical output from
  the control system.
\item Version control.\\
  As a variation of the reproducibility requirement and also built on top of it,
  we must be able to revert to a previous software configuration at a later time
  in order to reproduce and double-check an earlier result.
  The use of a proper version control system on the settings and code for
  the computer control system can allow this with additional features
  including easy visualization of setting change and parallel development of code
  by multiple users.
\end{enumerate}

The design of the computer control system is mainly guided by these requirements
and we will go into more detail as we describe each part of the system.
The application programming interface (API) provided for sequence and scan programming
are mostly text based due to the flexibility and version control requirement.
Some graphic user interface (GUI) are also included for specific tasks
built on top of the text interface but will not be covered in this chapter.
Section \ref{ch:computer-control:frontend} will cover the frontend of the system
which is used by the user directly to specify an experimental sequence.
Section \ref{ch:computer-control:backend} will discuss the support for various
hardware backends used to run a sequence.
After that, section \ref{ch:computer-control:scan} describes how multiple sequences
can be put together to form a scan and
we will talk about some planned update to the system in section
\ref{ch:computer-control:summary}.

\section{Frontend}
\label{ch:computer-control:frontend}

The frontend is the main user interface of the system to specify a sequence.
Its API is designed around the a few concepts that can be divided into two categories,
\begin{enumerate}
\item Timing
  \begin{enumerate}
  \item (Sub-)sequence\\
    This represent a series of events that has fixed relative timing.
    Sequences can be nested in other sequences at a specific time offset
    and are called subsequences.
    Each sequence can only have at most one parent sequence (the top level one has none)
    and zero or more subsequences so all the subsequences in a top level sequence forms a tree.
  \item Time step\\
    The time or time period in the sequence when one or more event may happen
    is called a time step.
    Each time step has a length and a position within a unique parent sequence.
  \end{enumerate}
\item Output
  \begin{enumerate}
  \item Channel\\
    Each device that can generate an output are abstracted into
    one or multiple channels that each output a single number.
    The abstraction depends on the type of the device,
    e.g. voltage value for a digital to analog converter,
    or frequency and amplitude for an computer-controlled sine-wave generator.
  \item Pulse\\
    This represents the actual output for a particular channel.
    The pulse itself does not contain the timing information within the sequence,
    i.e. start and end time.
    Instead, each pulse belongs to a unique time step that specifies the timing.
  \end{enumerate}
\end{enumerate}
Operations on concepts in one category are usually independent of the other
which allows most common modifications to the sequence to be done
with minimum code change, including,
\begin{enumerate}
\item Adding/removing/changing the length of time step or subsequences
  without affecting the relative timing or output in other part of the sequence.
\item Enabling/disabling output or changing output values
  without changing the time and length of the output.
\end{enumerate}

The sequence programming uses MATLAB as the host language.
Despite not the best choice from the feature or performance aspect,
it offers the following desired properties,
\begin{enumerate}
\item Text based language and therefore easier for version control.
\item Familiarity for physics student.\\
  MATLAB is often used for simulation and data processing.
  It is one of the few languages that most new students will be familiar with.
\item Builtin feature-rich integrated development environment (IDE).
\item Foreign function interface (FFI).\\
  Other parts of the system needs to be implemented in other languages
  for various reasons including higher performance.
  It is important that we can call into other languages to allow such a hybrid implementation.
\item Good enough feature set.\\
  MATLAB provides data structures like arrays and hash table
  as well as handle classes with object identity
  which are important to handle the representation of the sequence.
  It also has an good enough object-oriented programming (OOP) model
  and operator overloads which can simplify the API syntax for the user.
\end{enumerate}

(Backward compatibility)
(Flexibility)

\section{Backends}
\label{ch:computer-control:backend}
(communication protocol)
(IR)

\subsection{FPGA Backend}
(clock generation)
(pulse merging)
(compression)

\subsection{NiDAQ Backend}
(Variable clock)

\subsection{USRP Backend}
(SIMD)

\section{Automation of Scan}
\label{ch:computer-control:scan}

(Scan requirement)
(Combination of scans)
(Scope/nested structure)

\section{Summary and Outlook}
\label{ch:computer-control:summary}
(new backend/SPCM)
(native code generation, auto vectorization)
(dynamic logic and dependency tracking/optimization)
