% -*- mode: latex-mode; TeX-engine: xetex; LaTeX-command-style: (("" "SOURCE_DATE_EPOCH=0 %(PDF)%(latex) --shell-escape %S%(PDFout)")); TeX-master: "../dissertation.tex"; -*-

\chapter{Computer Control of the Experiment}
\label{ch:computer-control}

\section{Introduction}

The experiment sequence and data taking is managed by computers.
In additional to controlling the timing and the actions during a sequence,
the computer control system is also the main interface
between the people running the experiment (the user),
the data and the hardware performing the manipulation and measurements.
Because of its central role in the experiment,
it has to satisfy many requirements so that
the daily operation of the lab can be performed smoothly and reliably.
\begin{enumerate}
\item Full control and utilization of hardware.\\
  The control system is a layer in between the the user and the hardware
  and will abstract and manage the hardware on behave of the user.
  However, the abstraction must still allow the user to take advantage of
  the full capability of the hardware, e.g. output resolution, timing accuracy etc..
  This is because there is usually little margin between the capability of the hardware
  and the requirement in the experiment as the specification of the hardware
  is often selected based on the requirement to begin with.
\item Usability for all lab members.\\
  The lab is operated by users with specialty in physics rather than computer science.
  Although some basic knowledge of computer programming is required for operating
  the experiment as well as analysing data,
  the computer control system must be fully usable for people without any experience
  in building complex software systems.\\
  The inevitable complexity of the system must be fully hidden from the user
  for normal operations although more direct control may still be allowed in certain cases.
\item Modeling of the sequence and scan.\\
  As an important special case of usability,
  the computer control system must provide a model for each tasks closed to
  the users' mental model.
  More concretely, this means creating abstraction for concepts
  typically used to describe the task and allow operation on these abstractions
  matching the users' expectation.
  We will talk about concrete examples of this requirements
  in section \ref{ch:computer-control:frontend} regarding the sequence frontend
  and section \ref{ch:computer-control:scan} regarding scan automation.
\item Reproducibility.\\
  When exploring something new in the experiment,
  trial and error is the standard method and troubleshooting is a major part of the process.
  The ability to do this effectively requires a high degree of reproducibility of all the result.
  While it is impossible and also not the job of the computer control system to
  eliminate all the fluctuation and noise in the experiment,
  it should not add to the randomness of the system.
  With few exceptions, identical user input should produce identical output from
  the control system.
\item Version control.\\
  As a variation of the reproducibility requirement and also built on top of it,
  we must be able to revert to a previous software configuration at a later time
  in order to reproduce and double-check an earlier result.
  The use of a proper version control system on the settings and code for
  the computer control system can allow this with additional features
  including easy visualization of setting change and parallel development of code
  by multiple users.
\end{enumerate}

The design of the computer control system is mainly guided by these requirements
and we will go into more detail as we describe each part of the system.
The application programming interface (API) provided for sequence and scan programming
are mostly text based due to the flexibility and version control requirement.
Some graphic user interface (GUI) are also included for specific tasks
built on top of the text interface but will not be covered in this chapter.
Section \ref{ch:computer-control:frontend} will cover the frontend of the system
which is used by the user directly to specify an experimental sequence.
Section \ref{ch:computer-control:backend} will discuss the support for various
hardware backends used to run a sequence.
After that, section \ref{ch:computer-control:scan} describes how multiple sequences
can be put together to form a scan and
we will talk about some planned update to the system in section
\ref{ch:computer-control:summary}.

\section{Frontend}
\label{ch:computer-control:frontend}

The frontend is the main user interface of the system to specify a sequence.
Its API is designed around the a few concepts that can be divided into two categories,
\begin{enumerate}
\item Timing
  \begin{enumerate}
  \item (Sub-)sequence\\
    This represent a series of events that has fixed relative timing.
    Sequences can be nested in other sequences at a specific time offset
    and are called subsequences.
    Each sequence can only have at most one parent sequence (the top level one has none)
    and zero or more subsequences so all the subsequences in a top level sequence forms a tree.
  \item Time step\\
    The time or time period in the sequence when one or more event may happen
    is called a time step.
    Each time step has a length and a position within a unique parent sequence
    and are always the leaves on the sequence tree.
  \end{enumerate}
\item Output
  \begin{enumerate}
  \item Channel\\
    Each device that can generate an output are abstracted into
    one or multiple channels that each output a single number.
    The abstraction depends on the type of the device,
    e.g. voltage value for a digital to analog converter,
    or frequency and amplitude for an computer-controlled sine-wave generator.
  \item Pulse\\
    This represents the actual output for a particular channel.
    The pulse itself does not contain the timing information within the sequence,
    i.e. start and end time.
    Instead, each pulse belongs to a unique time step that specifies the timing.
  \end{enumerate}
\end{enumerate}
Operations on concepts in one category are usually independent of the other
which allows most common modifications to the sequence to be done
with minimum code change, including,
\begin{enumerate}
\item Adding/removing/changing the length of time step or subsequences
  without affecting the relative timing or output in other part of the sequence.
\item Enabling/disabling output or changing output values
  without changing the time and length of the output.
\end{enumerate}

The sequence programming uses MATLAB as the host language.
Despite not the best choice from the feature or performance aspect,
it offers the following desired properties,
\begin{enumerate}
\item Text based language and therefore easier for version control.
\item Familiarity for physics student.\\
  MATLAB is often used for simulation and data processing.
  It is one of the few languages that most new students will be familiar with.
\item Builtin feature-rich integrated development environment (IDE).
\item Foreign function interface (FFI).\\
  Other parts of the system needs to be implemented in other languages
  for various reasons including higher performance.
  It is important that we can call into other languages to allow such a hybrid implementation.
\item Good enough feature set.\\
  MATLAB provides data structures like arrays and hash table
  as well as handle classes with object identity
  which are important to handle the representation of the sequence.
  It also has an good enough object-oriented programming (OOP) model
  and operator overloads which can simplify the API syntax for the user.
\end{enumerate}

\subsection{APIs}
The system provides the following APIs for sequence creation
that are subject to strict backward compatibility requirements.
The most important APIs are listed in this section.

\subsubsection{Timing}
Most timing related APIs are methods on the class representing (sub-)sequences
(\verb`ExpSeqBase`). The most important ones are the ones creating new branches
in the subsequence tree, i.e. subsequences or time steps.
The type of the branch created is determined by the parameters passed in
(\verb`<time_params>`), which can be either,
\begin{enumerate}
\item \verb`length, offset=0`\\
  This creates a new time step with a numerical \verb`length`
  and an optional time \verb`offset` from a API dependent time reference point
  (see list of APIs below).
\item \verb`offset=0, callback, <callback parameters>`\\
  This creates a new subsequence with an optional time \verb`offset` the time reference point.
  The new subsequence will be populated by calling \verb`callback`
  with the new sequence followed by \verb`<callback parameters>`.
\end{enumerate}
Since most sequences are built in series, \verb`ExpSeqBase` maintains
a current time (\verb`curTime`) of the sequence.
Various methods are provided that acts differently with respect to \verb`curTime`.
\begin{enumerate}
\item \verb`addStep(<time_params>)` method\\
  This is the most used method to construct the sequence in series.
  The time reference point is \verb`curTime` and
  \verb`curTime` will be set to the end of the time step or subsequence created.
  A check is make sure the \verb`curTime` only moves forward and
  errors if a too negative \verb`offset` is specified.
  This ensures that what added with \verb`addStep` always appears in the final
  sequence in the same order as program execution order
  which makes the code easier to reason about.
\item \verb`addBackground(<time_params>)` method\\
  The time reference point is \verb`curTime` and no change to \verb`curTime` is made.
\item \verb`addAt(time_point, <time_params>)` method\\
  The time reference point is specified by \verb`time_point` which is of type \verb`TimePoint`.
  See below about \verb`TimePoint`.
\item \verb`addFloating(<time_params>)` method\\
  The time reference point is unspecified and must be set later
  by the \verb`setTime` method below.
  The optional \verb`offset` parameter cannot be specified in \verb`<time_params>`.
\end{enumerate}
All methods return the new subsequence or time step constructed
so that they can be operated on.

        %% Wait API's
        % Allow waiting for time, background sequences, everything,
        % or specific subsequences or steps.

        % function self = wait(self, t)
        %     %% Forward current time.
        % function self = waitAll(self)
        %     %% Wait for everything that have been currently added to finish.
        %     % This is the recursive version of `waitBackground`.
        % function self = waitFor(self, steps, offset)
        %     %% Wait for all the steps or subsequences within `steps` with an offset.
        %     % It is allowed to wait for steps or subsequences that are not a child
        %     % of `self`. It is also allowed to wait for floating sequence provided
        %     % that all the floating part is shared (i.e. only the common parents are floating
        %     % and the offset between `self` and the step to be waited for is well defined).
        % function self = waitBackground(self)
        %     %% Wait for background steps that are added directly to this sequence
        %     % to finish. See also `waitAll`.
        % %% Other helper functions.
        %%
        % Position a currently floating step/sub sequence (`self`)
        % The `anchor` percentage point of the current `TimeSeq` will be positioned
        % `offset` after the time point. The length of the current sequence
        % is the current time for sub sequences (`ExpSeqBase`)
        % and length for steps (`TimeStep`), consistent with the logic in `TimePoint`.
        %
        % NOTE: The choice of the definition for `TimeStep` is obvious and the choice for
        %   `ExpSeqBase` is because current time is what's more visible to the user
        %   than the total length of the subsquence including all background sequence.
        %   In fact, total length of the sequence is rarely useful/reliable
        %   since sub-sequences within the current sequence could have late background steps
        %   that are very hard to discover.

\subsubsection{Output}
            %% Add a pulse on a channel to the step.
            % The channel name can be provided as a string, which will be
            % translated and converted to the channel ID, or it can be
            % given as the channel ID (number) directly. (See `TimeSeq::translateChannel`)
            % The pulse can be
            %
            % * A number
            %
            %     Output the value at the beginning of the step.
            %
            % * A subclass of `PulseBase`
            %
            %     The `calcValue` method will be used to compute the output value.
            %
            % * Or an arbitrary callable object/function handle.
            %
            %     Equivalent as a `FuncPulse`. The object will be called to
            %     compute the output value.

\section{Backends}
\label{ch:computer-control:backend}
(communication protocol)
(IR)

\subsection{FPGA Backend}
(clock generation)
(pulse merging)
(compression)

\subsection{NiDAQ Backend}
(Variable clock)

\subsection{USRP Backend}
(SIMD)

\section{Automation of Scan}
\label{ch:computer-control:scan}

(Scan requirement)
(Combination of scans)
(Scope/nested structure)

\section{Summary and Outlook}
\label{ch:computer-control:summary}
(new backend/SPCM)
(native code generation, auto vectorization)
(dynamic logic and dependency tracking/optimization)
